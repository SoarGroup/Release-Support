% ----------------------------------------------------------------------------
\typeout{--------------- The SYNTAX of soar programs ------------------------}
\chapter{The Syntax of Soar Programs}
%\label{performance}
\label{SYNTAX}
\index{syntax!productions|see{production!syntax}}
\index{syntax!working memory elements|see{working memory element!syntax}}
\index{syntax!preferences|see{preference!syntax}}

This chapter describes in detail the syntax of elements in working
memory, preference memory, and production memory, and how impasses and
I/O are represented in working memory and in productions. Working memory
elements and preferences are created as Soar runs, while productions are
created by the user or through chunking. The bulk of this chapter
explains the syntax for writing productions.

The first section of this chapter describes the structure of working
memory elements in Soar; the second section describes the structure of
preferences; and the third section describes the structure of
productions. The fourth section describes the structure of impasses.
An overview of how input and output appear in working memory is
presented in the fifth section; the full discussion of Soar I/O can be
found in the \textit{SML Quick Start Guide}.

This chapter assumes that you understand the operating principles of
Soar, as presented in Chapter \ref{ARCH}.

% ----------------------------------------------------------------------------
\section{Working Memory}
\label{SYNTAX-wm}
\index{working memory!syntax}
\index{working memory element!syntax}

Working memory contains \emph{working memory elements} (WME's). As
described in Section \ref{ARCH-wm}, WME's can be created by the actions of 
productions, the evaluation of preferences, the Soar
architecture, and via the input/output system.

\index{identifier}
\index{attribute}
\index{value}
\index{^ (carat symbol)}
A WME is a list consisting of three symbols: an {\em identifier}, an
\emph{attribute}, and a \emph{value}, where the entire WME is enclosed in
parentheses and the attribute is preceded by an up-arrow (\carat ).
A template for a working memory element is:
\begin{verbatim}
(identifier ^attribute value)
\end{verbatim}

The identifier is an internal symbol, generated by the Soar architecture as
it runs. The attribute and value can be either identifiers or constants; if
they are identifiers, there are other working memory elements that have 
that identifier in their first position.  As the previous sentences
demonstrate, identifier is used to refer both to the first position of
a working memory element, as well as to the symbols that occupy that position.


% ----------------------------------------------------------------------------
\subsection{Symbols}
\label{SYNTAX-wm-symbols}

Soar distinguishes between two types of working memory symbols:
\emph{identifiers} and {\em constants}. 
\index{symbol}

\index{identifier}
\textbf{Identifiers: } An identifier is a unique symbol, created at runtime when 
a new object is added to working memory. The names of 
identifiers are
created by Soar, and consist of a single uppercase letter followed by a string
of digits, such as \soar{G37} or \soar{O22}.

(The Soar user interface will also allow users to specify identifiers using
lowercase letters, for example, when using the \texttt{print} command.
But internally, they are actually uppercase letters.)

\index{constant}
\textbf{Constants: } There are three types of constants: integers,
floating-point, and symbolic constants:\vspace{-10pt}
\index{constant}
\begin{itemize} 

\index{integer}
\item Integer constants (numbers).  The range of values depends on the
        machine and implementation you're using, but it is at least $[$-2
        billion..2 billion$]$.\vspace{-8pt}

\index{floating-point constants}
\item Floating-point constants (numbers).  The range depends on
        the machine and implementation you're using.\vspace{-8pt}
        
\item Symbolic constants.  These are symbols with arbitrary names. A constant
        can use any combination of letters, digits, or \verb.$%&*+-/:<=>?_.
        Other characters (such as blank spaces) can be included by surrounding
        the complete constant name with vertical bars: \soar{|This is a
        constant|}.  (The vertical bars aren't part of the name; they're just
        notation.)  A vertical bar can be included by prefacing it with a
        backslash inside surrounding vertical bars:
        \verb.|Odd-symbol\|name|.\vspace{-8pt}
\end{itemize} 
\index{attribute}
\index{value}
\index{constant}
\index{symbolic constant}

Identifiers should not be confused with constants, although they may ``look
the same''; identifiers are generated (by the Soar architecture) at runtime
and will not necessarily be the same for repeated runs of the same program.
Constants are specified in the Soar program and will be the same for repeated
runs.

Even when a constant ``looks like'' an identifier, it will not act like
an identifier in terms of matching. A constant is printed surrounded by
vertical bars whenever there is a possibility of confusing it with an
identifier: \soar{|G37|} is a constant while \soar{G37} is an
identifier. To avoid possible confusion, you should not use
letter-number combinations as constants or for production names.

\subsection{Objects}

Recall from Section \ref{ARCH-wm} that all WME's that share an
identifier are collectively called an \textit{object} in working memory.
The individual working memory elements that make up an object are often
called \emph{augmentations}, because they augment the object.  A
template for an object in working memory is:
\begin{verbatim}
(identifier ^attribute-1 value-1 ^attribute-2 value-2 
            ^attribute-3 value-3... ^attribute-n value-n)
\end{verbatim}

For example, if you run Soar with the example blocks-world program described
in Appendix \ref{BLOCKSCODE}, after one elaboration cycle, you can look at the
top-level state by using the \soar{print} command:
\label{example:prints1}
\begin{verbatim}
soar> print s1
(S1 ^io I1 ^ontop O2 ^ontop O3 ^ontop O1 ^problem-space blocks 
    ^superstate nil ^thing B3 ^thing T1 ^thing B1 ^thing B2 
    ^type state)
\end{verbatim} \vspace{12pt}
The attributes of an object are printed in alphabetical order to make it easier 
to find a specific attribute.

\index{attribute!multi-valued attribute}
\index{multi-attributes|see{attribute!multi-valued attribute}}
Working memory is a set, so that at any time, there are never duplicate
versions of working memory elements.  However, it is possible for
several working memory elements to share the same identifier and
attribute but have different values.  Such attributes are called
multi-valued attributes or \emph{multi-attributes}.  For example, state
\soar{S1}, above, has two attributes that are multi-valued: \soar{thing} and 
\soar{ontop}. 


% ----------------------------------------------------------------------------
\subsection{Timetags}
\index{timetag}
\index{working memory element!timetag|see{timetag}}

When a working memory element is created, Soar assigns it a unique
integer \textit{timetag}. The timetag is a part of the working memory
element, and therefore, WME's are actually quadruples, rather than
triples. However, the timetags are not represented in working memory and
cannot be matched by productions. The timetags are used to distinguish
between multiple occurrences of the same WME. As preferences change and
elements are added and deleted from working memory, it is possible for
a WME to be created, removed, and created again. The second creation of
the WME --- which bears the same identifier, attribute, and value as the
first WME --- is \textit{different}, and therefore is assigned a
different timetag. This is important because a production will fire only
once for a given instantiation, and the instantiation is determined by
the timetags that match the production and not by the
identifier-attribute-value triples.

To look at the timetags of WMEs, the \soar{wmes} command can be used:
\begin{verbatim}
soar> wmes s1
(3: S1 ^io I1)
(10: S1 ^ontop O2)
(9: S1 ^ontop O3)
(11: S1 ^ontop O1)
(4: S1 ^problem-space blocks)
(2: S1 ^superstate nil)
(6: S1 ^thing B3)
(5: S1 ^thing T1)
(8: S1 ^thing B1)
(7: S1 ^thing B2)
(1: S1 ^type state)
\end{verbatim} \vspace{12pt}
This shows all the individual augmentations of \soar{S1}, each is preceded by
an integer \textit{timetag}.

% ----------------------------------------------------------------------------
\subsection{Acceptable preferences in working memory}
\label{SYNTAX-wm-preferences}
\index{working memory!acceptable preference}
\index{preference!acceptable}

The acceptable preferences for the operator augmentations of states
appear in working memory as identifier-attribute-value-preference
quadruples. No other preferences appear in working memory. A template
for an acceptable preference in working memory is:
\begin{verbatim}
(identifier ^operator value +)
\end{verbatim} \vspace{12pt}

For example, if you run Soar with the example blocks-world program described
in Appendix \ref{BLOCKSCODE}, after the first operator
has been selected, you can again look at the top-level state using the
\soar{wmes} command:

\begin{verbatim}
soar> wmes s1
(3: S1 ^io I1)
(9: S1 ^ontop O3)
(10: S1 ^ontop O2)
(11: S1 ^ontop O1)
(48: S1 ^operator O4 +)
(49: S1 ^operator O5 +)
(50: S1 ^operator O6 +)
(51: S1 ^operator O7 +)
(54: S1 ^operator O7)
(52: S1 ^operator O8 +)
(53: S1 ^operator O9 +)
(4: S1 ^problem-space blocks)
(2: S1 ^superstate nil)
(5: S1 ^thing T1)
(8: S1 ^thing B1)
(6: S1 ^thing B3)
(7: S1 ^thing B2)
(1: S1 ^type state)
\end{verbatim} \vspace{12pt}

The state \soar{S1} has six augmentations of acceptable preferences for
different operators (\soar{O4} through \soar{O9}). These have plus signs
following the value to denote that they are acceptable preferences. The state
has exactly one operator, \soar{O7}. This state corresponds to the
illustration of working memory in Figure \ref{fig:ab-wmem2}.
\index{preference}
\index{object}

% ----------------------------------------------------------------------------
\subsection{Working Memory as a Graph}
\index{link}
\index{identifier}
\index{object}

Not only is working memory a set, it is also a graph structure where the
identifiers are nodes, attributes are links, and constants are terminal
nodes.  Working memory is not an arbitrary graph, but a graph rooted in
the states.  Therefore, all WMEs are \emph{linked} either directly or
indirectly to a state.  The impact of this constraint is that all WMEs
created by actions are linked to WMEs tested in the conditions.  The
link is one-way, from the identifier to the value. Less commonly, the
attribute of a WME may be an identifier.

\begin{figure}
\insertfigure{o43net}{4in}
\insertcaption{A semantic net illustration of four objects in working memory.}
\label{fig:o43net}
\end{figure}

Figure \ref{fig:o43net} illustrates four objects in working memory; the
object with identifier \soar{X44} has been linked to the object with
identifier \soar{O43}, using the attribute as the link, rather than the
value. The objects in working memory illustrated by this figure are:
\begin{verbatim}
(O43 ^isa apple ^color red ^inside O53 ^size small ^X44 200) 
(O87 ^isa ball ^color red ^inside O53 ^size big)
(O53 ^isa box ^size large ^color orange ^contains O43 O87)
(X44 ^unit grams ^property mass)
\end{verbatim} \vspace{12pt}

In this example, object \soar{O43} and object \soar{O87} are both linked to
object \soar{O53} through \soar{(O53 \carat contains O43)} and \soar{(O53
\carat contains O87)}, respectively (the \soar{contains} attribute
is a multi-valued attribute). Likewise, object \soar{O53} is linked to object
\soar{O43} through \soar{(O43 \carat inside O53)} and linked to object
\soar{O87} through \soar{(O87 \carat inside O53)}. Object \soar{X44} is linked
to object \soar{O43} through \soar{(O43 \carat X44 200)}.

Links are transitive so that \soar{X44} is linked to \soar{O53} (because
\soar{O43} is linked to \soar{O53} and \soar{X44} is linked to
\soar{O43}). However, since links are not symmetric, \soar{O53} is not
linked to \soar{X44}.


% ----------------------------------------------------------------------------
% ----------------------------------------------------------------------------
\section{Preference Memory}
\label{SYNTAX-prefmem}
\index{preference memory!syntax}
\index{preference!syntax}

Preferences are created by production firings and express the
relative or absolute merits for selecting an operator for a state.  When
preferences express an absolute rating, they are
identifier-attribute-value-preference quadruples; when preferences
express relative ratings, they are
identifier-attribute-value-preference-value quintuples

For example, 
\begin{verbatim}
(S1 ^operator O3 +)
\end{verbatim}
is a preference that asserts that operator O3 is an acceptable operator for
state S1, while
\begin{verbatim}
(S1 ^operator O3 > O4)
\end{verbatim}
is a preference that asserts that operator O3 is a better choice for the
operator of state S1 than operator O4.

The semantics of preferences and how they are processed were described in
Section \ref{ARCH-prefmem}, which also described each of the eleven different
types of preferences.  Multiple production instantiations may create identical 
preferences. Unlike working memory, preference memory is not a set: Duplicate 
preferences are allowed in preference memory.
% ----------------------------------------------------------------------------
% ----------------------------------------------------------------------------
\section{Production Memory}
\label{SYNTAX-pm}
\index{production!syntax}
\index{production memory!syntax}

\nocomment{XXXX start here with indexing}

Production memory contains productions, which can be loaded in by a user
(typed in while Soar is running or \soar{source}d from a file) or
generated by chunking while Soar is running. Productions (both
user-defined productions and chunks) may be examined using the
\soar{print} command, described in Section \ref{print} on page
\pageref{print}.

Each production has three required components: a name, a set of conditions
(also called the left-hand side, or LHS), and a set of actions (also called the
right-hand side, or RHS).  There are also two optional components: a 
documentation string and a type.

Syntactically, each production consists of the symbol \soar{sp}, followed
by: an opening curly brace, \soar{\{}; the production's name; the
documentation string (optional); the production type (optional);
comments (optional); the production's conditions; the symbol \soar{-->}
(literally: dash-dash-greaterthan); the production's actions; and a
closing curly brace, \soar{\}}.  Each element of a production is
separated by white space. Indentation and linefeeds are used by
convention, but are not necessary.

\begin{verbatim}
sp {production-name
    Documentation string
    :type
    CONDITIONS
    -->
    ACTIONS
    }
\end{verbatim}  \vspace{12pt}

\begin{figure}
\begin{verbatim}
sp {blocks-world*propose*move-block
   (state <s> ^problem-space blocks
              ^thing <thing1> {<> <thing1> <thing2>}
              ^ontop <ontop>)
   (<thing1> ^type block ^clear yes)
   (<thing2> ^clear yes)
   (<ontop> ^top-block <thing1>
            ^bottom-block <> <thing2>)
   -->
   (<s> ^operator <o> +)
   (<o> ^name move-block 
        ^moving-block <thing1> 
        ^destination <thing2>)}
\end{verbatim}
\insertcaption{An example production from the example blocks-world task.}
\label{fig:ex-prod}
\end{figure}

An example production, named ``\soar{blocks-world*propose*move-block}'', is
shown in Figure \ref{fig:ex-prod}. This production proposes operators named 
\soar{move-block} that move blocks
from one location to another. The details of this production will be described
in the following sections.

\subsubsection*{Conventions for indenting productions}

Productions in this manual are formatted using conventions designed to
improve their readability. These conventions are not part of the
required syntax. First, the name of the production immediately follows
the first curly bracket after the \soar{sp}.  All conditions are aligned
with the first letter after the first curly brace, and attributes of an
object are all aligned The arrow is indented to align with the
conditions and actions and the closing curly brace follows the last
action.

% ----------------------------------------------------------------------------
\subsection{Production Names}

The name of the production is  an almost arbitrary constant. (See Section
\ref{SYNTAX-wm-symbols} for a description of constants.) By convention, the
name describes the role of the production, but functionally, the name is
just a label primarily for the use of the programmer.  

A production name should never be a single letter followed by numbers, 
which is the format of identifiers.

The convention for naming productions is to separate important elements
with asterisks; the important elements that tend to appear in the name
are:\vspace{-12pt}
\begin{enumerate}
\item The name of the task or goal (e.g., \texttt{blocks-world}).\vspace{-10pt}
\item The name of the architectural function (e.g., \texttt{propose}).\vspace{-
10pt}
\item The name of the operator (or other object) at issue. (e.g.,
        \texttt{move-block})\vspace{-10pt} 
\item Any other relevant details.
\end{enumerate}


This name convention enables one to have a good idea of the function of
a production just by examining its name. This can help, for example,
when you are watching Soar run and looking at the specific productions
that are firing and retracting.  Since Soar uses white space to delimit
components of a production, if whitespace inadvertently occurs in the
production name, Soar will complain that an open parenthesis was
expected to start the first condition.

\subsection{Documentation string (optional)}

A production may contain an optional documentation string. The syntax
for a documentation string is that it is enclosed in double quotes and
appears after the name of the production and before the first condition
(and may carry over to multiple lines). The documentation string allows
the inclusion of internal documentation about the production; it will be
printed out when the production is printed using the \soar{print}
command.

% ----------------------------------------------------------------------------
\subsection{Production type (optional)}

A production may also include an optional \emph{production type}, which
may specify that the production should be considered a default
production (\soar{:default}) or a chunk (\soar{:chunk}), or may specify
that a production should be given O- support (\soar{:o-support}) or
I-support (\soar{:i-support}).  Users are discouraged from using these
types.  These types are described in Section \ref{sp}, which begins on
Page \pageref{sp}.

There is one additional flag (\soar{:interrupt}) which can be placed at this location
in a production. However this flag does not specify a production type, but is
a signal that the production should be marked for special debugging capabilities. For more
information, see Section \ref{sp} on Page \pageref{sp}.

% ----------------------------------------------------------------------------
\subsection{Comments (optional)}
\index{comments}

Productions may contain comments, which are not stored in Soar when the
production is loaded, and are therefore not printed out by the
\soar{print} command. A comment is begun with a pound sign character
\soar{\#} and ends at the end of the line.  Thus, everything following
the \soar{\#} is not considered part of the production, and comments
that run across multiple lines must each begin with a \soar{\#}.

For example:
\begin{verbatim}
sp {blocks-world*propose*move-block
   (state <s> ^problem-space blocks
              ^thing <thing1> {<> <thing1> <thing2>}
              ^ontop <ontop>)
   (<thing1> ^type block ^clear yes)
   (<thing2> ^clear yes)
#   (<ontop> ^top-block <thing1>
#           ^bottom-block <> <thing2>)
   -->
   (<s> ^operator <o> +)
   (<o> ^name move-block         # you can also use in-line comments
        ^moving-block <thing1>
        ^destination <thing2>)}
\end{verbatim}

When commenting out conditions or actions, be sure that all parentheses
remain balanced outside the comment.

\subsubsection*{External comments}

Comments may also appear in a file with Soar productions, outside
 the curly braces of the \soar{sp} command.  Comments
must either start a new line with a \soar{\#} or start with \soar{;\#}.
In both cases, the comment runs to the end of the line.

\begin{verbatim}
# imagine that this is part of a "Soar program" that contains 
# Soar productions as well as some other code.

source blocks.soar      ;# this is also a comment
\end{verbatim}


% ----------------------------------------------------------------------------
% ----------------------------------------------------------------------------
% ----------------------------------------------------------------------------
\subsection{The condition side of productions (or LHS)}
\label{SYNTAX-pm-conditions}            %perf-cond
\index{condition side}
\index{LHS of production}
\index{production!LHS}
\index{production!condition}

The condition side of a production, also called the left-hand side (or
LHS) of the production, is a pattern for matching one or more WMEs. When
all of the conditions of a production match elements in working memory,
the production is said to be instantiated, and is ready to perform its
action.

The following subsections describe the condition side of a production,
including predicates, disjunctions, conjunctions, negations, acceptable
preferences for operators, and a few advanced topics. 
% A grammar for the
% condition side is given in Appendix \ref{GRAMMARS}.

% ----------------------------------------------------------------------------
\subsubsection{Conditions}
\label{Conditions}
\index{Conditions}

The condition side of a production consists of a set of conditions.
Each condition tests for the existence or absence (explained later in
Section \ref{SYNTAX-pm-negated}) of working memory elements. Each
condition consists of a open parenthesis, followed by a test for the
identifier, and the tests for augmentations of that identifier, in terms
of attributes and values.  The condition is terminated with a close
parenthesis.  Thus, a single condition might test properties of a single
working memory element, or properties of multiple working memory
elements that constitute an object.  
\begin{verbatim}
(identifier-test ^attribute1-test value1-test 
                 ^attribute2-test value2-test
                 ^attribute3-test value3-test
                 ...)
\end{verbatim}
The first condition in a production must match against a state in
working memory.  Thus, the first condition must begin with the
additional symbol ``state''.  All other conditions and actions must be
\textit{linked} directly or indirectly to this condition. This linkage
may be direct to the state, or it may be indirect, through objects
specified in the conditions.  If the identifiers of the actions are not
linked to the state, a warning is printed when the production is parsed,
and the production is not stored in production memory.  In the actions
of the example production shown in Figure \ref{fig:ex-prod}, the
operator preference is directly linked to the state and the remaining
actions are linked indirectly via the operator preference.

Although all of the attribute tests in the template above are followed
by value tests, it is possible to test for only the existence of an
attribute and not test any specific value by just including the
attribute and no value.  Another exception to the above template is
operator preferences, which have the following structure where a plus
sign follows the value test.
\begin{verbatim}
(state-identifier-test ^operator value1-test +
                 ...)
\end{verbatim}

In the remainder of this section, we describe the different tests that
can be used for identifiers, attributes, and values.  The simplest of
these is a constant, where the constant specified in the attribute or
value must match the same constant in a working memory element.

% ----------------------------------------------------------------------------
\subsubsection{Variables in productions}
\label{SYNTAX-pm-variables}
\index{variables}

Variables match against constants in working memory elements in the
identifier, attribute, or value positions.  Variables can be further
constrained by additional tests (described in later sections) or by
multiple occurrences in conditions.  If a variable occurs more than once
in the condition of a production, the production will match only if the
variables match the same identifier or constant.  However, there is no
restriction that prevents different variables from binding to the same
identifier or constant.

Because identifiers are generated by Soar at run time, it impossible to
include tests for specific identifiers in conditions.  Therefore,
variables are used in conditions whenever an identifier is to be
matched.

Variables also provide a mechanism for passing identifiers and constants
which match in conditions to the action side of a rule.

Syntactically, a variable is a symbol that begins with
a left angle-bracket (i.e., \soar{<}), ends with a right angle-bracket (i.e.,
\soar{>}), and contains at least one alphanumeric symbol in between.

In the example production in Figure \ref{fig:ex-prod}, there are seven
variables: \soar{<s>}, \soar{<clear1>}, \soar{<clear2>}, \soar{<ontop>},
\soar{<block1>}, \soar{<block2>}, and \soar{<o>}.

The following table gives examples of legal and illegal variable names.

\begin{tabular}{| l | l |} \hline
\bf{Legal variables} &  \bf{Illegal variables} \\ \hline
\soar{<s>} &  \soar{<>} \\
\soar{<1>} & \soar{<1} \\
\soar{<variable1>} & \soar{variable>} \\
\soar{<abc1>} & \soar{<a b>} \\ \hline 
\end{tabular} \vspace{10pt}

% ----------------------------------------------------------------------------
\subsubsection{Predicates for values}
\label{SYNTAX-pm-predicates}    %perf-pred}
\index{predicates}
\index{=}
\index{<>}
\index{<}
\index{<=}
\index{>=}
\index{>}
\index{<=>}

A test for an identifier, attribute, or value in a condition (whether
constant or variable) can be modified by a preceding predicate. There
are six predicates that can be used:
\soar{<>, <=>, <, <=, >=, >}.  

\begin{tabular}{| l | l |} \hline
\bf{Predicate} &  \bf{Semantics of Predicate} \\ \hline
\soar{<>}  & Not equal. Matches anything except the value immediately \\
           &  following it. \\
\soar{<=>} & Same type.  Matches any symbol that is the same type (identifier, 
\\
           &  integer, floating-point, non-numeric constant) as the value \\
           &  immediately following it. \\
\soar{<}   & Numerically less than the value immediately following it. \\
\soar{<=}  & Numerically less than or equal to the value immediately \\
           &  following it. \\
\soar{>=}  & Numerically greater than or equal to the value immediately \\ 
           &  following it. \\
\soar{>}   & Numerically greater than the value immediately following it. \\  
\hline 
\end{tabular} \vspace{10pt}
\index{numeric comparisons}
\index{type comparisons}
\index{not equal test}

The following table shows examples of legal and illegal predicates:

\begin{tabular}{| l | l |} \hline
\bf{Legal predicates} &  \bf{Illegal predicates} \\ \hline
\soar{> <valuex>} & \soar{> > <valuey>} \\
\soar{< 1}  & \soar{1 >} \\
\soar{<=> <y>} & \soar{= 10} \\  \hline
\end{tabular} \vspace{10pt}

\subsubsection*{Example Production}

\begin{verbatim}
sp {propose-operator*to-show-example-predicate
   (state <s> ^car <c>)
   (<c> ^style convertible ^color <> rust)
   -->
   (<s> ^operator <o> +)
   (<o> ^name drive-car ^car <c>) }
\end{verbatim}

In this production, there must be a ``color'' attribute for the working memory
object that matches \verb+<c>+, and the value of that attribute must not be
``rust''. 

% ----------------------------------------------------------------------------
\subsubsection{Disjunctions of values}
\label{SYNTAX-pm-disjuncts}      %perf-disj
\index{disjunction of constants}
\index{<< >>}

A test for an identifier, attribute, or value may also be for a
disjunction of constants. With a disjunction, there will be a match if any
one of the constants is found in a working memory element (and the other
parts of the working memory element matches). Variables and predicates
may not be used within disjunctive tests.

Syntactically, a disjunctive test is specified with double angle brackets
(i.e., \soar{ <<} and \soar{>>}). There must be spaces separating the brackets
from the constants. 

The following table provides examples of legal and illegal disjunctions:

\begin{tabular}{| l | l |} \hline
\bf{Legal disjunctions} &  \bf{Illegal disjunctions} \\ \hline
\soar{<< A B C 45 I17 >>} &  \soar{<< <A> A >>}  \\
\soar{<< 5 10 >>} &  \soar{<< < 5  > 10 >>}  \\
\soar{<< good-morning good-evening >>} & \soar{<<A B C >>} \\  \hline 
\end{tabular} \vspace{10pt}

\subsubsection*{Example Production}
For example, the third condition of the following
production contains a disjunction that restricts the color of the table to
\soar{red} or \soar{blue}:

\begin{verbatim}
sp {blocks*example-production-conditions
   (state ^operator <o> + ^table <t>)
   (<o> ^name move-block)
   (<t> ^type table ^color << red blue >> )
   -->
   ... }
\end{verbatim}

\subsubsection*{Note}
Disjunctions of complete conditions are not allowed in Soar.  Multiple
(similar) productions fulfill this role.


% ----------------------------------------------------------------------------
\subsubsection{Conjunctions of values}
\label{SYNTAX-pm-conjunctions}  %perf-conj}
\index{conjunctive!conditions}

A test for an identifier, attribute, or value in a condition may include
a conjunction of tests, all of which must hold for there to be a match.

Syntactically, conjuncts are contained within curly braces (i.e., \soar{\{}
and \soar{\}}). The following table shows some examples of legal and illegal
conjunctive tests:

\begin{tabular}{| l | l |} \hline
\bf{Legal conjunctions} &  \bf{Illegal conjunctions} \\  \hline
\soar{\{ <= <a> >= <b> \}} & \soar{\{ <x> < <a> + <b> \}} \\
\soar{\{ <x> > <y> \}}     & \soar{\{ > > <b> \}} \\
\soar{\{ <> <x> <y> \}}    & \\
\soar{\{ << A B C >> <x> \}} & \\
\soar{\{ <=> <x> > <y> << 1 2 3 4 >> <z> \}} & \\  \hline
\end{tabular} \vspace{10pt}

Because those examples are a bit difficult to interpret, let's go over the
legal examples one by one to understand what each is doing.

In the first example, the value must be less than or equal to the value bound
to variable \soar{<a>} and greater than or equal to the value bound to
variable \soar{<b>}.

In the second example, the value is bound to the variable \soar{<x>}, which
must also be greater than the value bound to variable \soar{<y>}. 

In the third example, the value must not be equal to the value bound to
variable \soar{<x>} and should be bound to variable \soar{<y>}.  Note the
importance of order when using conjunctions with predicates: in the second
example, the predicate modifies \soar{<y>}, but in the third
example, the predicate modifies \soar{<x>}.

In the fourth example, the value must be one of \soar{A}, \soar{B}, or
\soar{C}, and the second conjunctive test binds the value to variable
\soar{<x>}. 

In the fifth example, there are four conjunctive tests. First, the value must
be the same type as the value bound to variable \soar{<x>}. Second, the value
must be greater than the value bound to variable \soar{<y>}. Third, the value
must be equal to \soar{1}, \soar{2}, \soar{3}, or \soar{4}. Finally, the value
should be bound to variable \soar{<z>}.

In Figure \ref{fig:ex-prod}, a conjunctive test is used for the \soar{thing}
attribute in the first condition.

% ----------------------------------------------------------------------------
\subsubsection{Negated conditions}
\label{SYNTAX-pm-negated}       %perf-nega-cond
\index{negated!conditions}
\index{-}

In addition to the positive tests for elements in working memory, conditions
can also test for the absence of patterns.  A \emph{negated condition} will be
matched only if there does not exist a working memory element consistent with
its tests and variable bindings. Thus, it is a test for the \textit{absence}
of a working memory element.

Syntactically, a negated condition is specified by preceding a condition with a
dash (i.e., ``\soar{-}'').

For example, the following condition tests the absence of a working memory
element of the object bound to \soar{<p1> \carat type father}.

\begin{verbatim}
-(<p1> ^type father)
\end{verbatim} \vspace{12pt}

A negation can be used within an object with many attribute-value pairs by
having it precede a specific attribute:

\begin{verbatim}
(<p1> ^name john -^type father ^spouse <p2>)
\end{verbatim} \vspace{12pt}

In that example, the condition would match if there is a working memory
element that matches \soar{(<p1> \carat name john)} and another that matches 
\soar{(<p1> \carat spouse <p2>)}, but is no working memory element that matches 
\soar{(<p1> \carat type father)} (when \soar{p1} is bound to the same 
identifier).

On the other hand, the condition:
\begin{verbatim}
-(<p1> ^name john ^type father ^spouse <p2>)
\end{verbatim}

would match only if there is no object in working memory that matches all
three attribute-value tests.

\subsubsection*{Example Production}
\begin{verbatim}
sp {default*evaluate-object
   (state <ss> ^operator <so>)
   (<so> ^type evaluation 
         ^superproblem-space <p>)
  -(<p> ^default-state-copy no)
   -->
   (<so> ^default-state-copy yes) }
\end{verbatim}

\subsubsection*{Notes}

One use of negated conditions to avoid is testing for the absence of the
working memory element that a production creates with I-support; this
would lead to an ``infinite loop'' in your Soar program, as Soar would
repeatedly fire and retract the production.


% ----------------------------------------------------------------------------
\subsubsection{Negated conjunctions of conditions}
\label{SYNTAX-pm-negaconj}      %perf-nega-conj}
\index{negated!conjunctions}
\index{conjunctive!negation}

Conditions can be grouped into conjunctive sets by surrounding the set of
conditions with \soar{\{} and \soar{\}}. The production compiler groups the
test in these conditions together. This grouping allows for negated tests of
more than one working memory element at a time. In the example below, the
state is tested to ensure that it does not have an object on the table. 

\begin{verbatim}
sp {blocks*negated-conjunction-example
   (state <s> ^name top-state)
  -{(<s> ^ontop <on>)
    (<on> ^bottom-object <bo>)
    (<bo> ^type table)}
   -->
   (<s> ^nothing-ontop-table true) } 
\end{verbatim}

When using negated conjunctions of conditions, the production has
nested curly braces. One set of curly braces delimits the production, while
the other set delimits the conditions to be conjunctively negated.

If only the last condition, \soar{(<bo> \carat type table)} were negated, the
production would match only if the state \emph{had} an ontop relation, and the
ontop relation had a bottom-object, but the bottom object wasn't a table.
Using the negated conjunction, the production will also match when the state
has no ontop augmentation or when it has an ontop augmentation that doesn't
have a bottom-object augmentation.

The semantics of negated conjunctions can be thought of in terms of
mathematical logic, where the negation of $(A \wedge B \wedge C)$:

$\neg (A \wedge B \wedge C)$

can be rewritten as:

$(\neg A) \vee (\neg B) \vee (\neg C)$

That is, ``not (A and B and C)'' becomes ``(not A) or (not B) or (not C)''.



% ----------------------------------------------------------------------------
\subsubsection{Multi-valued attributes}
\label{SYNTAX-pm-multi}
\index{multi-valued attribute}

An object in working memory may have multiple augmentations that specify
the same attribute with different values; these are called multi-valued
attributes, or multi-attributes for short.  To shorten the specification
of a condition, tests for multi-valued attributes can be shortened so
that the value tests are together.

For example, the condition:
\begin{verbatim}
(<p1> ^type father ^child sally ^child sue)
\end{verbatim}

could also be written as:
\begin{verbatim}
(<p1> ^type father ^child sally sue)
\end{verbatim}


% ----------------------------------------------------------------------------
\subsubsection*{Multi-valued attributes and variables}

When variables are used with multi-valued attributes, remember that
variable bindings are not unique unless explicitly forced to be so. For
example, to test that an object has two values for attribute
\soar{child}, the variables in the following condition can match to the same
value.

\begin{verbatim}
(<p1> ^type father ^child <c1> <c2>)
\end{verbatim} \vspace{12pt}

To do tests for multi-valued attributes with variables correctly,
conjunctive tests must be used, as in:

\begin{verbatim}
(<p1> ^type father ^child <c1> {<> <c1> <c2>})
\end{verbatim} \vspace{12pt}

The conjunctive test \soar{ \{<> <c1> <c2>\} } ensures that \soar{<c2>} will
bind to a different value than \soar{<c1>} binds to.


% ----------------------------------------------------------------------------
\subsubsection*{Negated conditions and multi-valued attributes}

A negation can also precede an attribute with multiple values.  In this case
it tests for the absence of the conjunction of the values.  For example

\begin{verbatim}
(<p1> ^name john -^child oprah uma)
\end{verbatim}

is the same as 

\begin{verbatim}
(<p1> ^name john)
-{(<p1> ^child oprah)
  (<p1> ^child uma)}
\end{verbatim}

and the match is possible if either \soar{(<p1> \carat child oprah)} or
\soar{(<p1> \carat child uma)} cannot be found in working memory with the
binding for \soar{<p1>} (but not if both are present).

% ----------------------------------------------------------------------------
\subsubsection{Acceptable preferences for operators}
\label{SYNTAX-pm-acceptable}
\index{condition!acceptable preference }
\index{preference!acceptable as condition}
\index{acceptable preference}
\index{+}

The only preferences that can appear in working memory are acceptable
preferences for operators, and therefore, the only preferences that may appear
in the conditions of a production are acceptable preferences for operators.

Acceptable preferences for operators can be matched in a condition by testing
for a ``\soar{+}'' following the value.  This allows a production to test the
existence of a candidate operator and its properties, and possibly create a
preference for it, before it is selected.

In the example below, \soar{\carat operator <o> +} matches the acceptable
preference for the operator augmentation of the state. \emph{This does not
test that operator} \soar{<o>} \emph{has been selected as the current
operator}.

\begin{verbatim}
sp {blocks*example-production-conditions
   (state ^operator <o> + ^table <t>)
   (<o> ^name move-block)
   -->
   ... }
\end{verbatim}


In the example below, the production tests the state for acceptable
preferences for two different operators (and also tests that these operators
move different blocks):

\begin{verbatim}
sp {blocks*example-production-conditions
   (state ^operator <o1> + <o2> + ^table <t>)
   (<o1> ^name move-block ^moving-block <m1> ^destination <d1>)
   (<o2> ^name move-block ^moving-block {<m2> <> <m1>} 
         ^destination <d2>)
   -->
   ... }
\end{verbatim}

\subsubsection{Attribute tests}

The previous examples applied all of the different test to the values of
working memory elements. 
All of the tests that can be used for values can also be used for
attributes and identifiers (except those including constants).

% ----------------------------------------------------------------------------
\subsubsection*{Variables in attributes}

Variables may be used with attributes, as in:

\begin{verbatim}
sp {blocks*example-production-conditions
   (state <s> ^operator <o> + 
              ^thing <t> {<> <t> <t2>} )
   (operator <o> ^name group 
                 ^by-attribute <a>
                 ^moving-block <t>
                 ^destination <t2>)
   (<t> ^type block ^<a> <x>)
   (<t2> ^type block ^<a> <x>)
   -->
   (<s> ^operator <o> >) }
\end{verbatim}

This production tests that there is acceptable operator that is trying to
group blocks according to some attribute, \soar{<a>}, and that block
\soar{<t>} and \soar{<t2>} both have this attribute (whatever it is), and have
the same value for the attribute.


% ----------------------------------------------------------------------------
\subsubsection*{Predicates in attributes}

Predicates may be used with attributes, as in:

\begin{verbatim}
sp {blocks*example-production-conditions
   (state ^operator <o> + ^table <t>)
   (<t> ^<> type table)
   -->
   ... }
\end{verbatim}

which tests that the object with its identifier bound to \soar{<t>} must have
an attribute whose value is \soar{table}, but the name of this attribute is
not \soar{type}.

% ----------------------------------------------------------------------------
\subsubsection*{Disjunctions of attributes}
\index{disjunctions of attributes}
\index{<< >>}

Disjunctions may also be used with attributes, as in:

\begin{verbatim}
sp {blocks*example-production-conditions
   (state ^operator <o> + ^table <t>)
   (<t> ^<< type name>> table)
   -->
   ... }
\end{verbatim}

which tests that the object with its identifier bound to \soar{<t>} must have
either an attribute \soar{type} whose value is \soar{table} or an attribute
\soar{name} whose value is \soar{table}.

% ----------------------------------------------------------------------------
\subsubsection*{Conjunctive tests for attributes}

Section \ref{SYNTAX-pm-conjunctions} illustrated the use of conjunctions for
the values in conditions. Conjunctive tests may also be used with attributes,
as in:

\begin{verbatim}
sp {blocks*example-production-conditions
   (state ^operator <o> + ^table <t>)
   (<t> ^{<ta> <> name} table)
   -->
   ... }
\end{verbatim}

which tests that the object with its identifier bound to \soar{<t>} must have
an attribute whose value is \soar{table}, and the name of this attribute is
not \soar{name}, and the name of this attribute (whatever it is) is bound to
the variable \soar{<ta>}.

When attribute predicates or attribute disjunctions are used with
multi-valued attributes, the production is rewritten internally to use a
conjunctive test for the attribute; the conjunctive test includes a
variable used to bind to the attribute name. Thus,

\begin{verbatim}
(<p1> ^type father ^ <> name sue sally)
\end{verbatim}

is interpreted to mean:

\begin{verbatim}
(<p1> ^type father ^ {<> name <a*1>} sue ^ <a*1> sally)
\end{verbatim}


% ----------------------------------------------------------------------------
\subsubsection{Attribute-path notation}
\label{SYNTAX-pm-path}
\index{dot notation}
\index{path notation}
\index{.}

Often, variables appear in the conditions of productions only to link the value
of one attribute with the identifier of another attribute. Attribute-path
notation provides a shorthand so that these intermediate variables do not need
to be included.

Syntactically, path notation lists a sequence of attributes separated by dots
(.), after the \carat \ in a condition.

For example, using attribute path notation, the production:

\begin{verbatim}
sp {blocks-world*monitor*move-block
   (state <s> ^operator <o>)
   (<o> ^name move-block
        ^moving-block <block1>
        ^destination <block2>)
   (<block1> ^name <block1-name>)
   (<block2> ^name <block2-name>)   
   -->
   (write (crlf) |Moving Block: | <block1-name>
                 | to: | <block2-name> ) }
\end{verbatim}

could be written as:

\begin{verbatim}
sp {blocks-world*monitor*move-block
   (state <s> ^operator <o>)
   (<o> ^name move-block
        ^moving-block.name <block1-name>
        ^destination.name <block2-name>)   
   -->
   (write (crlf) |Moving Block: | <block1-name>
                 | to: | <block2-name> ) }
\end{verbatim}

Attribute-path notation yields shorter productions that are easier to
write, less prone to errors, and easier to understand.

When attribute-path notation is used, Soar internally expands the conditions
into the multiple Soar objects, creating its own variables as needed.
Therefore, when you print a production (using the \soar{print} command), the
production will not be represented using attribute-path notation.


%----------------------------------------------------------------------------
\subsubsection*{Negations and attribute path notation}

\nocomment{can't negations be used with structured values? there's no
        description of this (yes -- bobd)}

A negation may be used with attribute path notation, in which case it amounts
to a negated conjunction. For example, the production:

\begin{verbatim}
sp {blocks*negated-conjunction-example
   (state <s> ^name top-state)
  -{(<s> ^ontop <on>)
    (<on> ^bottom-object <bo>)
    (<bo> ^type table)}
   -->
   (<s> ^nothing-ontop-table true) } 
\end{verbatim}

could be rewritten as:

\begin{verbatim}
sp {blocks*negated-conjunction-example
   (state <s> ^name top-state -^ontop.bottom-object.type table)
   -->
   (<s> ^nothing-ontop-table true) }
\end{verbatim}


% ----------------------------------------------------------------------------
\subsubsection*{Multi-valued attributes and attribute path notation}

\nocomment{can't multi-attributes be used with structured values? there's no
        description of this (yes -- bobd)}

Attribute path notation may also be used with multi-valued attributes, such as:

\begin{verbatim}
sp {blocks-world*propose*move-block
   (state <s> ^problem-space blocks
              ^clear.block <block1> { <> <block1> <block2> }
              ^ontop <ontop>)
   (<block1> ^type block)
   (<ontop> ^top-block <block1>
            ^bottom-block <> <block2>)
   -->
   (<s> ^operator <o> +)
   (<o> ^name move-block +
        ^moving-block <block1> +
        ^destination <block2> +) }
\end{verbatim}


\subsubsection*{Multi-attributes and attribute-path notation}
\label{SYNTAX-pm-caveat}

\textbf{Note:} It would not be advisable to write the production in Figure
\ref{fig:ex-prod} using attribute-path notation as follows:

\begin{verbatim}
sp {blocks-world*propose*move-block*dont-do-this
   (state <s> ^problem-space blocks
              ^clear.block <block1>
              ^clear.block { <> <block1> <block2> }
              ^ontop.top-block <block1>
              ^ontop.bottom-block <> <block2>)
   (<block1> ^type block)
   -->
   ...
   }
\end{verbatim}

This is not advisable because it corresponds to a different set of conditions
than those in the original production (the \soar{top-block} and
\soar{bottom-block} need not correspond to the same \soar{ontop} relation).
To check this, we could print the original production at the Soar prompt:

\begin{verbatim}
soar> print blocks-world*propose*move-block*dont-do-this
sp {blocks-world*propose*move-block*dont-do-this
    (state <s> ^problem-space blocks ^thing <thing2>
          ^thing { <> <thing2> <thing1> } ^ontop <o*1> ^ontop <o*2>)
    (<thing2> ^clear yes)
    (<thing1> ^clear yes ^type block)
    (<o*1> ^top-block <thing1>)
    (<o*2> ^bottom-block { <> <thing2> <b*1> })
    -->
    (<s> ^operator <o> +)
    (<o> ^name move-block 
         ^moving-block <thing1> 
         ^destination <thing2>) }
\end{verbatim}

Soar has expanded the production into the longer form, and created two
distinctive variables, \soar{$<$o*1$>$} and \soar{$<$o*2$>$} to represent the
\soar{ontop} attribute. These two variables will not necessarily bind to the
same identifiers in working memory.

% ----------------------------------------------------------------------------
\subsubsection*{Negated multi-valued attributes and attribute-path notation}

Negations of multi-valued attributes can be combined with attribute-path
notation. However; it is very easy to make mistakes when using negated
multi-valued attributes with attribute-path notation. Although it is
possible to do it correctly, we strongly discourage its use.

For example, 

\begin{verbatim}
sp {blocks*negated-conjunction-example
   (state <s> ^name top-state -^ontop.bottom-object.name table A)
   -->
   (<s> ^nothing-ontop-A-or-table true) }
\end{verbatim}

gets expanded to:

\begin{verbatim}
sp {blocks*negated-conjunction-example
   (state <s> ^name top-state)
  -{(<s> ^ontop <o*1>)
    (<o*1> ^bottom-object <b*1>)
    (<b*1> ^name A)
    (<b*1> ^name table)}
   -->
   (<s> ^nothing-ontop-A-or-table true) }
\end{verbatim}

This example does not refer to two different blocks with different
names. It tests that there is not an \soar{ontop} relation with a
\soar{bottom-block} that is named \soar{A} and named \soar{table}. Thus, this
production probably should have been written as:

\begin{verbatim}
sp {blocks*negated-conjunction-example
   (state <s> ^name top-state 
              -^ontop.bottom-object.name table
              -^ontop.bottom-object.name A)
   -->
   (<s> ^nothing-ontop-A-or-table true) }
\end{verbatim}

which expands to: 
\begin{verbatim}
sp {blocks*negated-conjunction-example
   (state <s> ^name top-state)
  -{(<s> ^ontop <o*2>)
    (<o*2> ^bottom-object <b*2>)
    (<b*2> ^name a)}
  -{(<s> ^ontop <o*1>)
    (<o*1> ^bottom-object <b*1>)
    (<b*1> ^name table)}
   -->
   (<s> ^nothing-ontop-a-or-table true +) }
\end{verbatim}

\subsubsection*{Notes on attribute-path notation}\vspace{-12pt}
\begin{itemize}
\item Attributes specified in attribute-path notation may not start with a
        digit. For example, if you type \soar{\carat foo.3.bar}, Soar thinks
        the \soar{.3} is a floating-point number. (Attributes that don't
        appear in path notation can begin with a number.)

\item Attribute-path notation may be used to any depth.

\item Attribute-path notation may be combined with structured values,
        described in Section \ref{SYNTAX-pm-structured}.

\end{itemize}


% ----------------------------------------------------------------------------
\subsubsection{Structured-value notation}
\label{SYNTAX-pm-structured}    %pref-struc-cond}
\index{structured value notation}
\index{production!structured values}
\index{value!structured notation}

Another convenience that eliminates the use of intermediate variables is 
structured-value notation. 

Syntactically, the attributes and values of a condition may be written where a
variable would normally be written. The attribute-value structure is delimited
by parentheses.

Using structured-value notation, the production in Figure \ref{fig:ex-prod}
(on page \pageref{fig:ex-prod}) may also be written as:

\begin{verbatim}
sp {blocks-world*propose*move-block
   (state <s> ^problem-space blocks
              ^thing <thing1> {<> <thing1> <thing2>}
              ^ontop (^top-block <thing1>
                      ^bottom-block <> <thing2>))
   (<thing1> ^type block ^clear yes)
   (<thing2> ^clear yes)
-->
   (<s> ^operator <o> +)
   (<o> ^name move-block
        ^moving-block <thing1>
        ^destination <thing2>) }
\end{verbatim}

Thus, several conditions may be ``collapsed'' into a single condition.


\subsubsection*{Using variables within structured-value notation}

Variables are allowed within the parentheses of structured-value notation to
specify an identifier to be matched elsewhere in the production. For example,
the variable \soar{<ontop>} could be added to the conditions (although it are
not referenced again, so this is not helpful in this instance):

\begin{verbatim}
sp {blocks-world*propose*move-block
   (state <s> ^problem-space blocks
              ^thing <thing1> {<> <thing1> <thing2>}
              ^ontop (<ontop> 
                      ^top-block <thing1>
                      ^bottom-block <> <thing2>))
   (<thing1> ^type block ^clear yes)
   (<thing2> ^clear yes)
   -->
   (<s> ^operator <o> +)
   (<o> ^name move-block
        ^moving-block <thing1>
        ^destination <thing2>) }
\end{verbatim}

Structured values may be nested to any depth. Thus, it is possible to write
our example production using a single condition with multiple structured
values:

\begin{verbatim}
sp {blocks-world*propose*move-block
   (state <s> ^problem-space blocks
              ^thing <thing1> 
                     ({<> <thing1> <thing2>}
                      ^clear yes)
              ^ontop (^top-block 
                        (<thing1>
                         ^type block 
                         ^clear yes)
                      ^bottom-block <> <thing2>) )
   -->
   (<s> ^operator <o> +)
   (<o> ^name move-block
        ^moving-block <thing1>
        ^destination <thing2>) }
\end{verbatim}


\subsubsection*{Notes on structured-value notation}\vspace{-12pt}
\begin{itemize}
\item Attribute-path notation and structured-value notation are orthogonal and
        can be combined in any way. A structured value can contain an
        attribute path, or a structure can be given as the value for an
        attribute path. 

\item Structured-value notation may also be combined with negations and with
        multi-attributes. 

\item Structured-value notation may not be used in the actions of productions.

\end{itemize}


% ----------------------------------------------------------------------------
% ----------------------------------------------------------------------------
\subsection{The action side of productions (or RHS)}
\label{SYNTAX-pm-action}
\index{RHS of production}
\index{production!RHS}
\index{action side of production}


The action side of a production, also called the right-hand side (or RHS) of
the production, consists of individual actions that can:
\begin{itemize}
\item Add new elements to working memory.
\item Remove elements from working memory.
\item Create preferences.
\item Perform other actions
\end{itemize}

When the conditions of a production match working memory, the production is
said to be instantiated, and the production will fire during the next
elaboration cycle. Firing the production involves performing the actions
\emph{using the same variable bindings} that formed the instantiation.

\subsubsection{Variables in Actions}
\index{variable!action side}
Variables can be used in actions.  A variable that appeared in the
condition side will be replaced with the value that is was bound to in
the condition.  A variable that appears only in the action side will be
bound to a new identifier that begins with the first letter of that
variable (e.g., \soar{<o>} might be bound to \soar{o234}). This symbol is
guaranteed to be unique and it will be used for all occurrences of the
variable in the action side, appearing in all working memory elements
and preferences that are created by the production action.

\subsubsection{Creating Working Memory Elements}
An element is created in working memory by specifying it as an action.
Multiple augmentations of an object can be combined into a single
action, using the same syntax as in conditions, including path notation
and multi-valued attributes. 
\begin{verbatim}
   -->
   (<s> ^block.color red
        ^thing <t1> <t2>) }
\end{verbatim}
The action above is expanded to be:
\begin{verbatim}
   -->
   (<s> ^block <*b>)
   (<*b> ^color red)
   (<s> ^thing <t1>)
   (<s> ^thing <t2>) }
\end{verbatim}
This will add four elements to working memory with the variables replaced
with whatever values they were bound to on the condition side.

Since Soar is case sensitive, different combinations of upper- and
lowercase letters represent \emph{different} constants. For example,
``\soar{red}'', ``\soar{Red}'', and ``\soar{RED}'' are all distinct symbols in
Soar. In many cases, it is prudent to choose one of uppercase or lowercase and
write all constants in that case to avoid confusion (and bugs).

The constants that are used for attributes and values have a few
restrictions on them:\vspace{-12pt} 
\begin{enumerate}
\item There are a number of architecturally created augmentations for state
        and impasse objects; see Section \ref{SYNTAX-impasses} for a listing of 
        these special augmentations. User-defined productions can not create
        or remove augmentations of states that use these
        attribute names.\vspace{-8pt}
\item Attribute names should not begin with a number if these attributes will
        be used in attribute-path notation.
\end{enumerate}

\subsubsection{Removing Working Memory Elements}

A element is explicitly removed from working memory by following the
value with a dash: \soar{-}, also called a reject.  

\begin{verbatim}
   -->
   (<s> ^block <b> -)}
\end{verbatim}

If the removal of a working memory element removes the only link between
the state and working memory elements that had the value of the removed
element as an identifier, those working memory elements will be
removed. This is applied recursively, so that all item that become
unlinked are removed.

The reject should be used with an action that will be o-supported.
If reject is attempted with I-support, the working memory element will
reappear if the reject loses I-support and the element still has
support.  

% ----------------------------------------------------------------------------
\subsubsection{The syntax of preferences}
\index{preference}

Below are the eleven types of preferences as they can appear in the actions of a
production for the selection of operators:
\label{pref-list}

\begin{tabular}{| l | l |} \hline
\bf{RHS preferences}                        & \bf{Semantics} \\ \hline
\soar{(id \carat operator value)}          & acceptable  \\ 
\soar{(id \carat operator value +)}        & acceptable  \\ 
\soar{(id \carat operator value !)}        & require \\ 
\soar{(id \carat operator value \tild)}    & prohibit \\
\soar{(id \carat operator value -)}        & reject \\
\soar{(id \carat operator value > value2)} & better \\
\soar{(id \carat operator value < value2)} & worse \\
\soar{(id \carat operator value >)}        & best  \\
\soar{(id \carat operator value <)}        & worst \\
\soar{(id \carat operator value =)}        & unary indifferent  \\
\soar{(id \carat operator value = value2)} & binary indifferent  \\
\soar{(id \carat operator value = number)} & numeric indifferent \\
\hline
\end{tabular} \vspace{10pt}
\index{+}
\index{"!}
\index{~}
\index{-}
\index{>}
\index{<}
\index{=}
\index{&}
\index{"@}


The identifier and value will always be variables, such as
\soar{(<s1> \carat operator <o1> > <o2>)}.

The preference notation appears similar to the predicate tests that
appear on the left-hand side of productions, but has very different
meaning. Predicates cannot be used on the right-hand side of a
production and you cannot restrict the bindings of variables on the
right-hand side of a production. (Such restrictions can happen only in
the conditions.)

Also notice that the \soar{+} symbol is optional when specifying acceptable
preferences in the actions of a production, although using this symbol
will make the semantics of your productions clearer in many instances. The
\soar{+} symbol will always appear when you inspect preference memory (with
the \soar{preferences} command).

Productions are never needed to delete preferences because preferences
will be retracted when the production no longer matches.  Preferences
should never be created by operator application rules, and they should
always be created by rules that will give only I-support to their actions.

% ----------------------------------------------------------------------------
\subsubsection{Shorthand notations for preference creation}

There are a few shorthand notations allowed for the creation of operator
preferences on the right-hand side of productions.

Acceptable preferences do not need to be specified with a \soar{+}
symbol. \soar{(<s> \carat operator <op1>)} is assumed to mean \soar{(<s> \carat
operator <op1> +)}.

Ambiguity can easily arise when using a preference that can be
either binary or unary: \soar{> < =}. The default assumption is that if a
value follows the preference, then the preference is binary. It will be unary
if a carat (up-arrow), a closing parenthesis, another preference, or a comma follows it. 

Below are four examples of legal, although unrealistic, actions that have the
same effect.

\begin{verbatim}
(<s> ^operator <o1> <o2> + <o2> < <o1> <o3> =, <o4>)
(<s> ^operator <o1> + <o2> + 
            <o2> < <o1> <o3> =, <o4> +)
(<s> ^operator <o1> <o2> <o2> < <o1> <o4> <o3> =)
(<s> ^operator <o1> ^operator <o2>
           ^operator <o2> < <o1> ^operator <o4> <o3> =)
\end{verbatim}

Any one of those actions could be expanded to the following list of
preferences: 
\begin{verbatim}
(<s> ^operator <o1> +)
(<s> ^operator <o2> +)
(<s> ^operator <o2> < <o1>)
(<s> ^operator <o3> =)
(<s> ^operator <o4> +)
\end{verbatim}

Note that structured-value notation may not be used in the actions of 
productions.

% ----------------------------------------------------------------------------
\subsubsection{Righthand-side Functions}

The fourth type of action that can occur in productions is called a 
\emph{righthand-side function}.  Righthand-side functions allow productions
to create side effects other than changing working memory.  The RHS functions
are described below, organized by the type of side effect they have.

% ----------------------------------------------------------------------------
\subsubsection{Stopping and pausing Soar}
\label{RHS-stopping}

\begin{description}
\index{halt}
\item [\soarb{halt} ---] Terminates Soar's execution and returns to 
the user prompt.  A \soar{halt} action irreversibly terminates the
running of a Soar program.
It should not be used if Soar is to be restarted (see the
 \soar{interrupt} RHS action below.)
\begin{verbatim}
sp {
    ...
    -->
    (halt) }
\end{verbatim} 

\item [\soarb{interrupt} --- ]
\index{interrupt}
        Executing this function causes Soar to stop at the end of the
        current phase, and return to the user prompt. This is similar 
        to \soar{halt}, but does not terminate the run.
        The run may be continued by issuing a \soar{run} command from
	the user interface.  The \soar{interrupt} RHS function has the
	same effect as typing \soar{stop-soar} at the prompt, except
	that there is more control because it takes effect exactly
	at the end of the phase that fires the production.
\begin{verbatim}
sp {
    ...
    -->
    (interrupt) }
\end{verbatim}
	
	\label{interrupt-directive}
	Soar execution may also be stopped immediately before a production
	fires, using the \soar{:interrupt} directive. This functionality is
	called a matchtime interrupt and is very useful for debugging. See
	Section	\ref{sp} on Page \pageref{sp} for more information.
	
\begin{verbatim}
sp {production*name
    :interrupt
    ...
    -->
    ...
    }
\end{verbatim}
\end{description}

% ----------------------------------------------------------------------------
\subsubsection{Text input and output}

The function \soar{write} is provided as a production
action to do simple output of text in Soar. Soar applications that
do extensive input and output of text should use Soar Markup Language (SML). To learn
about SML, read the "SML Quick Start Guide" which should be located in the "Documentation" 
folder of your Soar install.

 
\begin{description}
\index{write}
\item [\soarb{write} --- ] This function writes its arguments to the standard
        output. It does not automatically insert blanks, linefeeds, or carriage
        returns.  For example, if \soar{<o>} is bound to 4, then
\begin{verbatim}
sp {
    ...
    -->
    (write  <o> <o> <o> | x| <o> | | <o>) }
\end{verbatim}
        prints

\begin{verbatim}
444 x4 4
\end{verbatim}

\index{carriage return, line feed}
\index{crlf}
\item [\soarb{crlf} --- ] Short for ``carriage return, line feed'', this
        function can be called only within \soar{write}. It forces a new line
        at its position in the \soar{write} action. 
\begin{verbatim}
sp {
    ...
    -->
    (write <x> (crlf) <y>) }
\end{verbatim}


%\index{accept}
%\item [\soarb{accept} --- ] Suspends Soar's execution and waits for the user
%        to type a constant, followed by a carriage return. The result of
%        \soar{accept} is the constant. The accept function does not read 
%	in strings.  It accepts a
%        single constant (which may look like a string).
%        Soar applications that make extensive use of text input should be
%        implemented using Tcl and Tk functionality, described in the
%        \emph{Soar Advanced Applications Manual}.

%The \soarb{accept} function does not work properly under the TSI 
%(Tcl-Soar Interface), or any other Soar program that has a separate 
%``Agent Window'' instead of a Tcl or Wish Console.  In this instance, 
%users should employ the \soar{tcl} RHS function 
%(described on page \pageref{SYNTAX-pm-otheractions-tcl}) to get user
%input through a text widget.
%\begin{verbatim} 
%sp {
%    ...
%    -->
%    (<s> ^input (accept)) }
%\end{verbatim}

        \nocomment{Does this imply that a CR is not needed? I.e., will the
                constant be 'accepted' after a space is hit?
                }

\end{description}

% ----------------------------------------------------------------------------
\subsubsection{Mathematical functions}

The expressions described in this section can be nested to any depth. For all
of the functions in this section, missing or non-numeric arguments result 
in an error.


\begin{description}
\index{compute}
\index{arithmetic operations}
\index{floating-point number}
\item [\soarb{+, -, *, /} --- ]
        These symbols provide prefix notation mathematical functions.
        These symbols work similarly to C functions.  They will take either 
        integer or real-number arguments. The first three functions return 
        an integer when all arguments are integers
        and otherwise return a real number, and the last two functions
        always return a real number.  The \soar{-} symbol is also a
	unary function which, given a single argument, returns the
	product of the argument and \soar{-1}.  The \soar{/} symbol is
	also a unary function which, given a single argument, returns the
	reciprocal of the argument (1/x).

\begin{verbatim}
sp {
    ...
    -->
    (<s> ^sum (+ <x> <y>)
         ^product-sum (* (+ <v> <w>) (+ <x> <y>))
         ^big-sum (+ <x> <y> <z> 402)
         ^negative-x (- <x>))
}
\end{verbatim}

\item [\soarb{div, mod} --- ]
        These symbols provide prefix notation binary mathematical functions
        (they each take two arguments). These symbols work similarly to C
        functions: They will take only integer arguments (using reals results
        in an error) and return an integer: \soar{div} takes two integers and
        returns their integer quotient; \soar{mod} returns their remainder.

\begin{verbatim}
sp {
    ...
    -->
    (<s> ^quotient (div <x> <y>)
         ^remainder (mod <x> <y>)) }
\end{verbatim}

\item [\soarb{abs, atan2, sqrt, sin, cos} --- ]   
        These symbols provide prefix notation unary mathematical functions
        (they each take one argument). These symbols work similarly to C
        functions: They will take either integer or real-number arguments. The
        first function (\soar{abs}) returns an integer when its argument is an
        integer and otherwise returns a real number, and the last four
        functions always return a real number.  \soar{atan2} returns as
	a float in radians, the arctangent of (first\_arg / second\_arg).
	\soar{sin} and \soar{cos} take as arguments the angle in radians.

\begin{verbatim}
sp {
    ...
    -->
    (<s> ^abs-value (abs <x>)
         ^sqrt (sqrt <x>)) }
\end{verbatim}


% ----------------------------------------------------------------------------
\index{int}
\item [\soarb{int} --- ] Converts a single symbol to an integer constant. This
        function expects either an integer constant, symbolic constant, or
        floating point constant. The symbolic constant must be a string which
        can be interpreted as a single integer. The floating point constant is
        truncated to only the integer portion. This function essentially
        operates as a type casting function.

        For example, the expression \soar{2 + sqrt(6)} could be printed
        as an integer using the following:

\begin{verbatim}
sp {
    ...
    -->
    (write (+ 2 (int sqrt(6))) ) }
\end{verbatim}

% ----------------------------------------------------------------------------
\index{float}
\item [\soarb{float} --- ] Converts a single symbol to a floating point 
constant.
        This function expects either an integer constant, symbolic constant,
        or floating point constant. The symbolic constant must be a string
        which can be interpreted as a single floating point number. This
        function essentially operates as a type casting function. 

        For example, if you wanted to print out an integer expression as a
        floating-point number, you could do the following:

\begin{verbatim}
sp {
    ...
    -->
    (write (float (+ 2 3))) }
\end{verbatim}

% ----------------------------------------------------------------------------
\index{ifeq}
\item [\soarb{ifeq} --- ] Conditionally return a symbol.
        This function takes four arguments. It returns the third argument if
        the first two are equal and the fourth argument otherwise. Note that
        symbols of different types will always be considered unequal. For example,
        1.0 and 1 will be unequal because the first is a float and the second is
        an integer.

\begin{verbatim}
sp {example-rule
    (state <s> ^a <a> ^b <b>)
    ...
    -->
    (write (ifeq <a> <b> equal not-equal)) }
\end{verbatim}
\end{description}

% ----------------------------------------------------------------------------
\subsubsection{Generating and manipulating symbols}

A new symbol (an identifier) is generated on the right-hand side of a
production whenever a previously unbound variable is used. This section
describes other ways of generating and manipulating symbols on the right-hand
side. 

\begin{description}
\index{timestamp}
\item [\soarb{timestamp} --- ] This function returns a symbol whose print name 
is a
        representation of the current date and time. 

        For example:

\begin{verbatim}
sp {
    ...
    -->
    (write (timestamp)) }
\end{verbatim}

        When this production fires, it will print out a representation of the
        current date and time, such as:
\begin{verbatim}
soar> run 1 e
8/1/96-15:22:49
\end{verbatim}    


\index{make-constant-symbol}
\item [\soarb{make-constant-symbol} --- ] This function returns a new constant 
symbol
        guaranteed to be different from all symbols currently present in the
        system.  With no arguments, it returns a symbol whose name starts with
        ``\soar{constant}''.  With one or more arguments, it takes those
        argument symbols, concatenates them, and uses that as the
        prefix for the new symbol. (It may also append a number to the 
	resulting symbol, 
	if a symbol with that prefix as its name already exists.)

\begin{verbatim}
sp {
    ...
    -->
    (<s> ^new-symbol (make-constant-symbol)) }
\end{verbatim}

        When this production fires, it will create an augmentation in working
        memory such as:

\begin{verbatim}
(S1 ^new-symbol constant5)
\end{verbatim} \vspace{12pt}

        The production:

\begin{verbatim}
sp {
    ...
    -->
    (<s> ^new-symbol (make-constant-symbol <s> )) }
\end{verbatim}
        
        will create an augmentation in working memory such as:
\begin{verbatim}
(S1 ^new-symbol |S14|)
\end{verbatim}

        when it fires. The vertical bars denote that the symbol is a
        constant, rather than an identifier; in this example, the number 4 has
        been appended to the symbol S1.

        This can be particularly useful when used in conjunction with the
        \soar{timestamp} function; by using \soar{timestamp} as an argument to
        \soar{make-constant-symbol}, you can get a new symbol that is
        guaranteed to be unique. For example:

\begin{verbatim}
sp {
    ...
    -->
    (<s> ^new-symbol (make-constant-symbol (timestamp))) }
\end{verbatim}

        When this production fires, it will create an augmentation in working
        memory such as:

\begin{verbatim}
(S1 ^new-symbol 8/1/96-15:22:49)
\end{verbatim}    


\index{capitalize-symbol}
\item [\soarb{capitalize-symbol} --- ] Given a symbol, this function returns a
	new symbol with the first character capitalized. This function is
	provided primarily for text output, for example, to allow the first
        word in a sentence to be capitalized.

        \nocomment{This command is possibly obsolete, since Soar7 is case 
sensitive?}

\begin{verbatim}
(capitalize-symbol foo)
\end{verbatim}    

\index{concat}
\item [\soarb{concat} --- ] Given an arbitrary number of symbols, this function
        concatenates them together into a single constant symbol. For example,

\begin{verbatim}
sp {example
    (state <s> ^type state)
    -->
    (<s> ^name (concat foo bar (+ 2 4))) }
\end{verbatim}

       After this rule fires, the WME \verb=(S1 ^name foobar6)= will be added.

\end{description}

% ----------------------------------------------------------------------------
\subsubsection{User-defined functions and interface commands as RHS actions}
%\label{SYNTAX-pm-otheractions-tcl}

Any function which has a certain function signature may be registered with the
Kernel and called as a RHS function.  The function must have the following signature:

\begin{verbatim}
std::string MyFunction(smlRhsEventId id, void* pUserData, Agent* pAgent,
                  char const* pFunctionName, char const* pArgument);
\end{verbatim}

The Tcl and Java interfaces have similar function signatures. Any arguments passed
to the function on the RHS of a production are concatenated and passed to the function
in the pArgument argument.

Such a function can be registered with the kernel via the client interface by calling:

\begin{verbatim}
Kernel::AddRhsFunction(char const* pRhsFunctionName, RhsEventHandler 
                   handler, void* pUserData);
\end{verbatim}

The \soar{exec} and \soar{cmd} functions are used to call user-defined functions and interface
commands on the RHS of a production.

\begin{description}
\index{exec}
\item [\soarb{exec} --- ] Used to call user-defined registered functions. Any arguments are concatenated
without spaces. For example, if \soar{<o>} is bound to \soar{x}, then

\begin{verbatim}
sp {
   ...
   -->
   (exec MakeANote <o> 1) }
\end{verbatim}
   
will call the user-defined \soar{MakeANote} function with the argument "\soar{x1}".

The return value of the function, if any, may be placed in working memory or passed
to another RHS function. For example, the log of a number \soar{<x>} could be printed this way:

\begin{verbatim}
sp {
   ...
   -->
   (write |The log of | <x> | is: | (exec log(<x>))|) }
\end{verbatim}

where "\soar{log}" is a registered user-defined function.

\index{cmd}
\item[\soarb{cmd} --- ] Used to call built-in Soar commands. Spaces are inserted between concatenated 
arguments. For example, the production

\begin{verbatim}
sp {
   ...
   -->
   (write (cmd print --depth 2 <s>)) }
\end{verbatim}

will have the effect of printing the object bound to \soar{<s>} to depth 2.
\end{description}

%There are no safety nets with this function, and users are warned that they
%can get themselves into trouble if not careful.  Users should
%\emph{never} use the \soar{tcl} RHS function to invoke \soar{add-wme},
%\soar{remove-wme} or \soar{sp}.

% ----------------------------------------------------------------------------
\subsubsection{Controlling chunking}
\label{SYNTAX-pm-actions-learning}

\nocomment{These RHS actions have not been implemented as of this writing. The
        functionality is achieved using the user-interface functions
        ``chunky-problem-spaces'' and ``chunk-free-problem-spaces''; see
        online help or the web pages for details on these functions.}


Chunking is described in Chapter \ref{CHUNKING}.

The following two functions are provided as RHS actions to assist in
development of Soar programs; they are not intended to correspond to any
theory of learning in Soar. This functionality is provided as a development 
tool, so that learning may be turned off in specific problem spaces,
preventing otherwise buggy behavior.

The \soar{dont-learn} and \soar{force-learn} RHS actions are to be used with
specific settings for the \soar{learn} command (see page \pageref{learn}.)
Using the \soar{learn} command, learning may be set to one of \soar{on},
\soar{off}, \soar{except}, or \soar{only}; learning must be set to
\soar{except} for the \soar{dont-learn} RHS action to have any effect and
learning must be set to \soar{only} for the \soar{force-learn} RHS action to
have any effect.

\begin{description}
\index{dont-learn}
\item [\soarb{dont-learn} --- ] When learning is set to \soar{except},
        by default chunks can be formed in all states; the \soar{dont-learn}
        RHS action will cause learning to be turned off for the specified
        state.

\begin{verbatim}
sp {turn-learning-off
    (state <s> ^feature 1 ^feature 2 -^feature 3)
     -->
    (dont-learn <s>) }
\end{verbatim}

        The \soar{dont-learn} RHS action applies when \soar{learn} is 
	set to \soar{-except}, and has no effect when other settings for
        \soar{learn} are used.


\index{force-learn}
\item [\soarb{force-learn} --- ] When learning is set to \soar{only},
        by default chunks are not formed in any state; the \soar{force-learn}
        RHS action will cause learning to be turned on for the specified
        state.

\begin{verbatim}
sp {turn-learning-on
    (state <s> ^feature 1 ^feature 2 -^feature 3)
     -->
    (force-learn <s>) }
\end{verbatim}

        The \soar{force-learn} RHS action applies when \soar{learn}
	is set to \soar{-only}, and has no effect when other settings for
        \soar{learn} are used.

\end{description}

% ----------------------------------------------------------------------------
%\subsection{Writing Productions that Create O-supported Preferences}

\nocomment{there's no discussion of o-support in this chapter, and probably
        there should be. maybe a quick separate section on the syntax of
        o-supported productions?

        [things to mention in this section: you can't always tell whether a
        preference will have o-support just by looking at the production
        (o-support is determined at runtime), and rules for determining
        o-support.]  
        }


% ----------------------------------------------------------------------------
% ----------------------------------------------------------------------------
\section{Impasses in Working Memory and in Productions}
\label{SYNTAX-impasses}
\index{subgoal}
\index{impasse}

When the preferences in preference memory cannot be resolved unambiguously,
Soar reaches an impasse, as described in Section \ref{ARCH-impasses}:\vspace{-
12pt}
\begin{itemize}
\item When Soar is unable to select a new operator (in the decision cycle), it
        is said to reach an operator impasse.\vspace{-8pt}
\end{itemize}

All impasses appear as states in working memory, where they can be
tested by productions.  This section describes the structure of state
objects in working memory.

% ----------------------------------------------------------------------------
\subsection{Impasses in working memory}
\label{SYNTAX-impasseaug}       %perf-goal-impa}

There are four types of impasses. 

\nocomment{rewrite this section to show templates of what the objects look like
        in working memory for different types of impasses}

\index{decision!procedure}
\index{impasse}
Below is a short description of the four types of impasses. (This was
described in more detail in Section \ref{ARCH-impasses} on page
\pageref{ARCH-impasses}.)\vspace{-12pt}
\begin{enumerate}
\item \emph{tie}: when there is a collection of equally eligible operators
        competing for the value of a particular attribute;\vspace{-8pt}
\item \emph{conflict}: when two or more objects are better than each other,
        and they are not dominated by a third operator;\vspace{-8pt}
\item \emph{constraint-failure}: when there are conflicting necessity
        preferences; \vspace{-8pt}
\item \emph{no-change}: when the proposal phase runs to quiescence without 
        suggesting a new operator.
\end{enumerate}
\index{impasse!types}
\index{tie impasse}
\index{conflict impasse}
\index{constraint-failure impasse}
\index{no-change impasse}
\index{elaboration!phase}
\index{impasse!resolution}
\index{goal!termination}
\index{subgoal!termination}

The list
below gives the seven augmentations that the architecture creates on the
substate generated when an impasse is reached, and the
values that each augmentation can contain:\vspace{-12pt}
\begin{description} 
\item [\soar{\carat type state}] \vspace{-8pt} 

\item [\soar{\carat impasse}] Contains the impasse type: \soar{tie}, 
    \soar{conflict}, \soar{constraint-failure}, or \soar{no-change}.\vspace{-
8pt} 

\item [\soar{\carat choices}]Either \soar{multiple} (for tie and conflict
        impasses), \soar{constraint-failure} (for constraint-failure
        impasses), or \soar{none} (for no-change impasses).\vspace{-8pt} 

\item [\soar{\carat superstate}] Contains the identifier of the state in which 
        the impasse arose.\vspace{-8pt}
        \index{superstate}

\item [\soar{\carat attribute}] For multi-choice and constraint-failure 
impasses,
        this contains \soar{operator}. For
        no-change impasses, this contains the attribute of the last 
        decision with a value (\soar{state} or \soar{operator}).\vspace{-8pt}
\index{subgoal!augmentations}

\item [\soar{\carat item}] For multi-choice and constraint-failure impasses, 
this 
        contains all values involved in the tie, conflict, or
        constraint-failure. If the set of items that tie or conflict changes
        during the impasse, the architecture removes or adds the appropriate
        item augmentations without terminating the existing impasse.\vspace{-
8pt}
        \index{item (attribute)}

\item [\soar{\carat item-count}] For multi-choice and constraint-failure impasses, 
this 
        contains the number of values listed under the item augmentation above.\vspace{-8pt}
        \index{item-count (attribute)}

\item [\soar{\carat quiescence}] States are the only objects with 
\soar{quiescence
        t}, which is an explicit statement that quiescence (exhaustion of the
        elaboration cycle) was reached in the superstate.  If problem solving
        in the subgoal is contingent on quiescence having been reached, the
        substate should test this flag.  The side-effect is that no chunk will
        be built if it depended on that test. See Section
        \ref{CHUNKING-creation} on page \pageref{CHUNKING-creation} for
        details. This attribute can be ignored when learning is turned off.
        \index{quiescence t (augmentation)}
        \index{exhaustion}
\end{description} 

Knowing the names of these architecturally defined attributes and their
possible values will help you to write productions that test for the presence
of specific types of impasses so that you can attempt to resolve the impasse
in a manner appropriate to your program. Many of the default
productions in the \soar{demos/defaults} directory of the Soar distribution
 provide means for resolving
certain types of impasses. You may wish to make use of some of all of these
productions or merely use them as guides for writing your own set of
productions to respond to impasses.

\subsubsection*{Examples}

The following is an example of a substate that is created for a tie among
three operators:
\index{goal!examples}
\index{impasse!examples}
\begin{verbatim}
(S12 ^type state ^impasse tie ^choices multiple ^attribute operator 
     ^superstate S3 ^item O9 O10 O11 ^quiescence t)
\end{verbatim} \vspace{12pt}

The following is an example of a substate that is created for a no-change
impasse to apply an operator:
\begin{verbatim}
(S12 ^type state ^impasse no-change ^choices none ^attribute operator 
     ^superstate S3 ^quiescence t)
(S3 ^operator O2)
\end{verbatim} \vspace{12pt}

% ----------------------------------------------------------------------------
\subsection{Testing for impasses in productions}

Since states appear in working memory, they may also be
tested for in the conditions of productions.

% There are numerous examples of this in the set of default productions (see
% Section \ref{default} or Appendix \ref{DEFAULT} for more information).

For example, the following production tests for a constraint-failure impasse
on the top-level state.

\begin{verbatim}
sp {default*top-goal*halt*operator*failure
    "Halt if no operator can be selected for the top goal."
    :default
    (state <ss> ^impasse constraint-failure ^superstate <s>)
    (<s> ^superstate nil)
-->
    (write (crlf) |No operator can be selected for top goal.| )
    (write (crlf) |Soar must halt.| )
    (halt)
}
\end{verbatim}

% ----------------------------------------------------------------------------
\section{Soar I/O: Input and Output in Soar}
\label{SYNTAX-io}
\index{I/O}
\index{motor commands|see{I/O}}

Many Soar users will want their programs to interact with a real or simulated
environment. For example, Soar programs could control a robot, receiving sensory
\emph{inputs} and sending command \textit{outputs}. Soar programs might 
also interact with
simulated environments, such as a flight simulator. The mechanisms by which
Soar receives inputs and sends outputs to an external process is called
\emph{Soar I/O}.

This section describes how input and output are represented in working memory
and in productions.  The details of creating and registering the input and 
output functions for Soar are beyond the scope of this manual, but they are
described in the \textit{SML Quick Start Guide}.
This section is provided for the sake of Soar users who will be making
use of a program that has already been implemented, or for those who would
simply like to understand how I/O is implemented in Soar.
% A simple example
% of Soar I/O using Tcl is provided in Section (Appendix?) \ref{Interface-Tcl_I/O}.


% ----------------------------------------------------------------------------
\subsection{Overview of Soar I/O}

When Soar interacts with an external environment, it must make use of
mechanisms that allow it to receive input from that environment and to effect
changes in that environment. An external environment may be the real world or
a simulation; input is usually viewed as Soar's perception and output is
viewed as Soar's motor abilities.


\index{I/O!input functions}
\index{I/O!output functions}
\index{input functions|see{I/O!input functions}}
\index{output functions|see{I/O!output functions}}
Soar I/O is accomplished via \emph{input functions} and
\emph{output functions}. Input functions are called at the 
\emph{start}
of every execution cycle, and add elements directly to specific input
structures in working memory.  These changes to working memory
may change the set of productions that will fire or retract. 
Output functions are called
at the \emph{end} of every execution cycle and are processed in response to
changes to specific output structures in working memory.  An output function
is called only if changes have been made to the output-link structures in
working memory.

\index{I/O!io attribute}
\index{io attribute|see{I/O!io attribute}}
\index{I/O!input links}
\index{I/O!output links}
\index{input links|see{I/O!input links}}
\index{output links|see{I/O!output links}}
The structures for manipulating input and output in Soar are linked
to a predefined attribute of the
top-level state, called the \soar{io} attribute.  The \soar{io} attribute has
substructure to represent sensor inputs from the environment called
\emph{input links}; because these are represented in working memory, Soar
productions can match against input links to respond to an external
situation. Likewise, the \soar{io} attribute has substructure to
represent motor commands, called \emph{output links}. Functions that 
execute motor commands in the environment use the values on the output links 
to determine when and how they should execute an action.  Generally,
input functions create and remove elements on the input link to update
Soar's perception of the environment.  Output functions respond to values
of working memory elements that appear on Soar's output link strucure.



% ----------------------------------------------------------------------------
\subsection{Input and output in working memory}
\label{ADVANCED-io-wm}

All input and output is represented in working memory as substructure of the
\soar{io} attribute of the top-level state.  By default, the architecture
creates an \soar{input-link} attribute of the \soar{io} object and
an \soar{output-link} attribute of the io object. 
The values of the \soar{input-link} and \soar{output-link} attributes
are identifiers whose augmentations are the complete set of input and
output working memory elements, respectively.  Some Soar systems may 
benefit from having multiple input and output links, or that use names
which are more
descriptive of the input or output function, such as \soar{vision-input-link},
\soar{text-input-link}, or \soar{motor-output-link}.  In addition to
providing  the default \soar{io} substructure, the architecture allows
users to create multiple input and output links via productions
and I/O functions.  Any identifiers for \soar{io} substructure created
by the user will be assigned at run time and are not guaranteed to be
the same from run to run.  Therefore users should always employ
variables when referring to input and output links in productions.

Suppose a blocks-world task is implemented using a robot to move
actual blocks around, with a camera creating input to Soar and a robotic arm
executing command outputs. 
\begin{figure}
\insertfigure{blocks-inputlink}{3.5in}
\insertcaption{An example portion of the input link for the blocks-world task.}
\label{fig:blocks-inputlink}
\end{figure}
The camera image might be analyzed by a separate vision program; this program
could have as its output the locations of blocks on an xy plane.  
The Soar input function could take the
output from the vision program and create the following working memory
elements on the input link (all identifiers are assigned at runtime; 
this is just an example of possible bindings):

\begin{verbatim}
(S1 ^io I1)          [A]
(I1 ^input-link I2)  [A]
(I2 ^block B1)
(I2 ^block B2)
(I2 ^block B3)
(B1 ^x-location 1)
(B1 ^y-location 0)
(B1 ^color red)
(B2 ^x-location 2)
(B2 ^y-location 0)
(B2 ^color blue)
(B3 ^x-location 3)
(B3 ^y-location 0)
(B3 ^color yellow)
\end{verbatim} \vspace{12pt}

The '[A]' notation in the example is used to indicate the working memory
elements that are created by the architecture and not by the input function.
This configuration of blocks corresponds to all blocks on the table, as
illustrated in the initial state in Figure \ref{fig:blocks}.

\begin{figure}
\insertfigure{blocks-outputlink}{3.5in}
\insertcaption{An example portion of the output link for the blocks-world task.}
\label{fig:blocks-outputlink}
\end{figure}

Then, during the Apply Phase of the execution cycle, Soar productions could 
respond to an operator, such as ``move the red block
ontop of the blue block'' by creating a structure on the output link, such as:

\begin{verbatim}
(S1 ^io I1)           [A]
(I1 ^output-link I3)  [A]
(I3 ^name move-block)
(I3 ^moving-block B1)
(I3 ^x-destination 2)
(I3 ^y-destination 1)
(B1 ^x-location 1)
(B1 ^y-location 0)
(B1 ^color red)
\end{verbatim}  \vspace{12pt}

The '[A]' notation is used to indicate the working memory elements 
that are created by the architecture and not by productions.
An output function would look for specific structure in this output link and
translate this into the format required by the external program that controls
the robotic arm. Movement by the robotic arm would lead to changes in the 
vision system, which would later be reported on the input-link.

Input and output are viewed from Soar's perspective. An \emph{input
function} adds or deletes augmentations of the \soar{input-link} 
providing Soar with information about some occurrence external to Soar. An
\emph{output function} responds to substructure of the \soar{output-link}
produced by production firings, and causes some occurrence external to
Soar. Input and output occur through the \soar{io} attribute of the top-level
state exclusively.
\index{top-state!for I/O}

Structures placed on the input-link by an input function remain there until removed
by an input function. During this time, the structure continues to provide support for
any production that has matched against it. The structure does \emph{not} cause the production
to rematch and fire again on each cycle as long as it remains in working memory;
to get the production to refire, the structure must be removed and added again.



%The substructure of the input-link will remain in working memory until 
%the input function that
%created it removes it.  Thus working memory elements produced by an
%input function provide support for condition-matching
%in productions as long as the input persists in working memory, i.e.
%until the input function specifically removes the elements of the
%substructure.  However,
%a production that tests only a single element on the input structure will 
%result in instantiations that fire only once for each input element that
%matches.  The instantiation will not continue to fire for each matched
%input element, unless the element is removed and then added again.


% ----------------------------------------------------------------------------
\subsection{Input and output in production memory}
\label{ADVANCED-io-pm}

Productions involved in \emph{input} will test for specific attributes and
values on the input-link, while productions involved in \emph{output} will
create preferences for specific attributes and values on the output link.
For example, a simplified production that responds to the vision input 
for the blocks task might look like this:

\begin{verbatim}
sp {blocks-world*elaborate*input
    (state <s> ^io.input-link <in>)
    (<in> ^block <ib1>)
    (<ib1> ^x-location <x1> ^y-location <y1>)
    (<in> ^block {<ib2> <> <ib1>})
    (<ib2> ^x-location <x1> ^y-location {<y2> > <y1>})
    -->
    (<s> ^block <b1>)
    (<s> ^block <b2>)
    (<b1> ^x-location <x1>  ^y-location <y1> ^clear no)
    (<b2> ^x-location <x1>  ^y-location <y2> ^above <b1>)
}
\end{verbatim}  \vspace{12pt}

This production ``copies'' two blocks and their locations directly to 
the top-level state. 
%This is a generally a good idea when using input, since the input
%function may change the information on the link before the Soar program has
%finished using it.
It also adds information about the
relationship between the two blocks.  The variables used
for the blocks on the RHS of the production are deliberately different from the
variable name used for the block on the input-link in the LHS of the
production. If the variable were the same, the production would create 
a link into the structure of the input-link, rather than copy the information.
The attributes \soar{x-location} and
\soar{y-location} are assumed to be values and not identifiers, so the same
variable names may be used to do the copying.


A production that creates wmes on the output-link for the blocks task 
might look like this:

\begin{verbatim}
sp {blocks-world*apply*move-block*send-output-command
    (state <s> ^operator <o> ^io.output-link <out>)
    (<o> ^name move-block ^moving-block <b1> ^destination <b2>)
    (<b1> ^x-location <x1> ^y-location <y1>)
    (<b2> ^x-location <x2> ^y-location <y2>)
    -->
    (<out> ^move-block <b1>
           ^x-destination <x2> ^y-destination (+ <y2> 1))
}
\end{verbatim} \vspace{12pt}

This production would create substructure on the output-link that 
the output function could interpret as being a command to 
move the block to a new location.


